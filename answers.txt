Tristan Thomas - 1269492 - tkthomas
1. In general the RPC server should be able to accept calls from everyone provided they are aware of the level of security
used. My system does not implement any encryption or authentication which may be a problem for some users. Also, the decision
should also depend on the procedures registered with the server and whether they should be publicly available.

2. Authentication and other security features should be implemented by the RPC framework since this allows for a
standardised policy across all users and allows the functions that use the system to focus on their specific task. It should
however, allow the user to add additional security features if desired.

3. The most sensible transport layer protocol to use is TCP since reliability is important to ensure the data is sent to
and received from the server successfully and in order. This comes with additional overhead however, but if time is more
important than reliability, an RPC system likely isn't the best choice to begin with.

4. The main sockets should be created in the server/client initialisation functions. Following this, the server should
continually accept and create new sockets from clients in the rpc_serve_all function whilst the original listen socket
remains open.

5. As long as the client remembers to free the dynamically allocated memory, both static or dynamic allocation of rpc_client
is adequate since pointers of the statically allocated memory can still be passed into functions as pointers with members
being changed, though dynamic may be better as is simplifies the rpc_init_client/server. It may be better to statically
allocate rpc_server because even though the server is not meant to crash, if it does, no clean up is implemented to free it.

6. Inconsistent byte ordering between two hosts should not affect how the data is reproduced when sent over the network
as the standardised 'network byte order' (big endian) was used for all data. The functions used to ensure this network byte
order do not depend on the hosts byte ordering.


Application-Layer Protocol
This RPC application-layer protocol is designed to allow a client to call various procedures, stored on a server, as if
they were called locally. The protocol is designed to be system independent and work on systems with different byte-ordering
and size_t/int sizes by sending packets over the network in a standardised form. The data payload is sent as an int,
general data pointed to by a void pointer and the size of this general data. Functions on the server-side are first
registered by name which can be found by the client using this registered name. To send the name over the network, the
size of this string is sent as a header followed by the name. If found the server sends another packet with a unique
procedure ID as payload. The header for this packet is an int specifying if the procedure was found or not (if not the
client function returns NULL).
The procedure can now be called using this procedure ID. To specify to the server whether a procedure lookup or call is
necessary, a small packet is sent prior to both of these operations. To make a call, checks are made to ensure data is
consistent then the following packet is sent: First a header including the procedure ID and the size of the general data.
Followed by the integer and this general data.
The procedure can then be called and another packet can be sent back to the client. First a byte specifying whether the
return data is consistent and if so a similar packet as before is sent without the procedure ID.
There are various checks within this API that ensure that all data send is valid and that descriptive error messages are
printed to stderr without the client or server crashing.
The procedure ID and all integers are sent across the network as unsigned 64-bit integers, meaning a system with ints
defined greater than 64 bits results in an 'Overlength error'. The size of the general data is restricted to 4 bytes
(fixed size) so again, if the size is greater than 2^32 an 'Overlength error' is triggered. Additionally, if a size or
int is sent over the network to a host that cannot store the value sent in their int or size_t this error also results.
This application-layer protocol runs over the connection-oriented TCP to ensure reliable and in-order data transmission.
This protocol allows the API to work correctly even if packet losses in the IP layer. The alternative is a connectionless
protocol such as UDP, however this is not a reliable protocol which is needed to ensure all data is sent and received
correctly. This reliability is more important than the speed advantage of UDP since if speed was the main priority it is
likely favourable to run the procedures directly on the client. This chosen transport layer is ran over IPv6 Network Layer.
